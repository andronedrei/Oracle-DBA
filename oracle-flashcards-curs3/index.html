<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oracle Database Course 3 - Fi»ôiere: Control »ôi Redo Log</title>
    <style>
        :root {
            /* Primitive Color Tokens */
            --color-white: rgba(255, 255, 255, 1);
            --color-black: rgba(0, 0, 0, 1);
            --color-cream-50: rgba(252, 252, 249, 1);
            --color-cream-100: rgba(255, 255, 253, 1);
            --color-gray-200: rgba(245, 245, 245, 1);
            --color-gray-300: rgba(167, 169, 169, 1);
            --color-gray-400: rgba(119, 124, 124, 1);
            --color-slate-500: rgba(98, 108, 113, 1);
            --color-brown-600: rgba(94, 82, 64, 1);
            --color-charcoal-700: rgba(31, 33, 33, 1);
            --color-charcoal-800: rgba(38, 40, 40, 1);
            --color-slate-900: rgba(19, 52, 59, 1);
            --color-teal-300: rgba(50, 184, 198, 1);
            --color-teal-400: rgba(45, 166, 178, 1);
            --color-teal-500: rgba(33, 128, 141, 1);
            --color-teal-600: rgba(29, 116, 128, 1);
            --color-teal-700: rgba(26, 104, 115, 1);
            --color-teal-800: rgba(41, 150, 161, 1);
            --color-red-400: rgba(255, 84, 89, 1);
            --color-red-500: rgba(192, 21, 47, 1);
            --color-orange-400: rgba(230, 129, 97, 1);
            --color-orange-500: rgba(168, 75, 47, 1);

            --color-brown-600-rgb: 94, 82, 64;
            --color-teal-500-rgb: 33, 128, 141;
            --color-slate-900-rgb: 19, 52, 59;
            --color-slate-500-rgb: 98, 108, 113;

            --color-background: var(--color-cream-50);
            --color-surface: var(--color-cream-100);
            --color-text: var(--color-slate-900);
            --color-text-secondary: var(--color-slate-500);
            --color-primary: var(--color-teal-500);
            --color-primary-hover: var(--color-teal-600);
            --color-primary-active: var(--color-teal-700);
            --color-border: rgba(var(--color-brown-600-rgb), 0.2);

            --font-family-base: 'Segoe UI', 'Geist', 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            --font-size-base: 14px;
            --font-size-lg: 16px;
            --font-size-xl: 18px;
            --font-size-2xl: 20px;
            --font-size-3xl: 24px;
            --font-weight-medium: 500;
            --font-weight-semibold: 550;
            --font-weight-bold: 600;

            --space-8: 8px;
            --space-12: 12px;
            --space-16: 16px;
            --space-20: 20px;
            --space-24: 24px;
            --space-32: 32px;

            --radius-base: 8px;
            --radius-lg: 12px;
            --radius-xl: 16px;

            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);

            --duration-normal: 250ms;
            --ease-standard: cubic-bezier(0.16, 1, 0.3, 1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --color-gray-400-rgb: 119, 124, 124;
                --color-teal-300-rgb: 50, 184, 198;
                --color-gray-300-rgb: 167, 169, 169;
                --color-gray-200-rgb: 245, 245, 245;

                --color-background: var(--color-charcoal-700);
                --color-surface: var(--color-charcoal-800);
                --color-text: var(--color-gray-200);
                --color-text-secondary: rgba(var(--color-gray-300-rgb), 0.7);
                --color-primary: var(--color-teal-300);
                --color-primary-hover: var(--color-teal-400);
                --color-primary-active: var(--color-teal-800);
                --color-border: rgba(var(--color-gray-400-rgb), 0.3);
            }
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: var(--font-family-base);
            background: linear-gradient(135deg, #E67E22 0%, #D68910 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: var(--space-20);
            color: var(--color-white);
            -webkit-font-smoothing: antialiased;
        }

        .container {
            width: 100%;
            max-width: 900px;
            animation: fadeIn 0.6s var(--ease-standard);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        header {
            text-align: center;
            margin-bottom: var(--space-32);
        }

        h1 {
            font-size: var(--font-size-3xl);
            font-weight: var(--font-weight-bold);
            margin-bottom: var(--space-12);
            color: var(--color-white);
        }

        .progress {
            font-size: var(--font-size-lg);
            color: rgba(255, 255, 255, 0.8);
            font-weight: var(--font-weight-medium);
        }

        .card-container {
            perspective: 1000px;
            margin-bottom: var(--space-32);
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card {
            width: 100%;
            max-width: 600px;
            height: 400px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s var(--ease-standard);
            cursor: pointer;
            user-select: none;
        }

        .card.flipped {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            border-radius: var(--radius-xl);
            padding: var(--space-32);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-shadow: var(--shadow-xl);
            transition: box-shadow 0.3s var(--ease-standard);
        }

        .card:hover .card-face {
            box-shadow: 0 25px 35px -5px rgba(0, 0, 0, 0.15), 0 15px 15px -5px rgba(0, 0, 0, 0.08);
        }

        .card-front {
            background: linear-gradient(135deg, #E67E22 0%, #D68910 100%);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .card-back {
            background: linear-gradient(135deg, #D35400 0%, #A04000 100%);
            border: 2px solid rgba(255, 255, 255, 0.15);
            transform: rotateY(180deg);
        }

        .card-label {
            font-size: var(--font-size-base);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: var(--space-16);
            font-weight: var(--font-weight-semibold);
        }

        .card-content {
            font-size: var(--font-size-xl);
            line-height: 1.6;
            color: var(--color-white);
            overflow-y: auto;
            max-height: 320px;
            padding: var(--space-8);
        }

        .card-content::-webkit-scrollbar {
            width: 6px;
        }

        .card-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }

        .card-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }

        .card-content::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.4);
        }

        .controls {
            display: flex;
            gap: var(--space-12);
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: var(--space-16);
        }

        .btn {
            padding: var(--space-12) var(--space-24);
            font-size: var(--font-size-base);
            font-weight: var(--font-weight-semibold);
            border: none;
            border-radius: var(--radius-base);
            cursor: pointer;
            transition: all 0.2s var(--ease-standard);
            user-select: none;
            font-family: var(--font-family-base);
            box-shadow: var(--shadow-md);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:focus-visible {
            outline: 2px solid rgba(255, 255, 255, 0.5);
            outline-offset: 2px;
        }

        .btn-primary {
            background: rgba(255, 255, 255, 0.95);
            color: #E67E22;
        }

        .btn-primary:hover {
            background: var(--color-white);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.15);
            color: var(--color-white);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        .btn:disabled:hover {
            transform: none;
            box-shadow: var(--shadow-md);
        }

        .hint {
            text-align: center;
            font-size: var(--font-size-base);
            color: rgba(255, 255, 255, 0.6);
            margin-top: var(--space-16);
        }

        @media (max-width: 640px) {
            body {
                padding: var(--space-16);
            }

            h1 {
                font-size: var(--font-size-2xl);
            }

            .card {
                height: 350px;
            }

            .card-face {
                padding: var(--space-24);
            }

            .card-content {
                font-size: var(--font-size-lg);
                max-height: 270px;
            }

            .controls {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }
        }

        @keyframes bounce {
            0%, 100% {
                transform: rotateY(180deg) scale(1);
            }
            50% {
                transform: rotateY(180deg) scale(1.05);
            }
        }

        .card.flipped .card-back {
            animation: bounce 0.3s var(--ease-standard) 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Oracle Database Course 3 - Fi»ôiere: Control »ôi Redo Log</h1>
            <div class="progress" id="progress">Card 1 / 51</div>
        </header>

        <div class="card-container">
            <div class="card" id="flashcard" role="button" tabindex="0" aria-label="Flashcard - Click to flip">
                <div class="card-face card-front">
                    <div class="card-label">√éntrebare</div>
                    <div class="card-content" id="question"></div>
                </div>
                <div class="card-face card-back">
                    <div class="card-label">RƒÉspuns</div>
                    <div class="card-content" id="answer"></div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" id="prevBtn" aria-label="Previous card">
                ‚Üê Previous
            </button>
            <button class="btn btn-primary" id="nextBtn" aria-label="Next card">
                Next ‚Üí
            </button>
            <button class="btn btn-secondary" id="shuffleBtn" aria-label="Shuffle cards">
                üîÄ Shuffle
            </button>
            <button class="btn btn-secondary" id="resetBtn" aria-label="Reset to original order">
                ‚Ü∫ Reset
            </button>
        </div>

        <div class="hint">
            üí° Click the card or press Space to flip | Use Arrow keys to navigate
        </div>
    </div>

    <script>
        // Flashcard data for Course 3: Fi»ôiere Control »ôi Redo Log
        const flashcardsData = [
            { id: 1, question: "Ce este fi»ôierul de control √Æn Oracle?", answer: "Fi»ôier binar esen»õial care √ÆnregistreazƒÉ structura fizicƒÉ a BD: numele BD, loca»õia fisierelor de date »ôi Redo Log »ôi informa»õii despre checkpoint. FƒÉrƒÉ el, BD nu poate fi montatƒÉ." },
            { id: 2, question: "Ce informa»õii con»õine fi»ôierul de control?", answer: "Numele BD, loca»õia fisierelor de date »ôi Redo Log, numele tablespace-urilor, timestamp de la creare, numarul de secven»õƒÉ pentru Redo Log, informa»õii despre checkpoint, etc." },
            { id: 3, question: "Ce se √Ænt√¢mplƒÉ dacƒÉ fi»ôierul de control nu este disponibil?", answer: "BD nu poate fi montatƒÉ »ôi nici deschisƒÉ, de»ôi fisierele de date »ôi Redo Log pot exista »ôi fi consistente. Sunt necesare scenarii de restaurare." },
            { id: 4, question: "C√¢te copii ale fi»ôierului de control ar trebui sƒÉ existe?", answer: "Oracle recomandƒÉ minimum 2 copii exploatate √Æn paralel (multiplexate). Varianta cu un singur fisier este descurajatƒÉ pentru a preveni »ôtergerea accidentalƒÉ." },
            { id: 5, question: "Ce este parametrul CONTROL_FILES?", answer: "Parametru din init.ora care con»õine o listƒÉ de nume de fisiere de control care vor fi exploatate √Æn paralel: CONTROL_FILES = (/u01/..., /u02/..., /u03/...)" },
            { id: 6, question: "Care sunt pa»ôii pentru redenumirea unui fi»ôier de control?", answer: "1. SHUTDOWN. 2. Copiare fisier cu comenzi OS. 3. Editare init.ora »ôi modificare CONTROL_FILES. 4. STARTUP." },
            { id: 7, question: "C√¢nd este necesarƒÉ crearea unui nou fi»ôier de control?", answer: "C√¢nd toate fisierele de control sunt distruse »ôi nu existƒÉ salvƒÉri sau c√¢nd se dore»ôte schimbarea unor parametri permanen»õi ai BD (DB_NAME, MAXLOGFILES, etc.)." },
            { id: 8, question: "Ce face clauza RESETLOGS √Æn CREATE CONTROLFILE?", answer: "Se utilizeazƒÉ dacƒÉ s-a redenumit BD sau s-au pierdut »ôi fisiere de Redo Log odatƒÉ cu cele de control. ReseteazƒÉ numerele de secven»õƒÉ ale fisierelor Redo Log." },
            { id: 9, question: "Care este diferen»õa dintre RESETLOGS »ôi NORESETLOGS?", answer: "RESETLOGS reseteazƒÉ secven»õa Redo Log (folosit la redenumire/pierderi). NORESETLOGS pƒÉstreazƒÉ secven»õa veche (folosit pentru recuperƒÉri simple)." },
            { id: 10, question: "Care sunt pa»ôii pentru crearea unui nou fi»ôier de control?", answer: "1. Lista TOATE fisierele de date »ôi Redo Log. 2. SHUTDOWN normal. 3. Salvare fisiere. 4. STARTUP NOMOUNT. 5. CREATE CONTROLFILE. 6. Salvare FC. 7. Editare init.ora. 8. Recovery. 9. ALTER DATABASE OPEN." },
            { id: 11, question: "Ce comandƒÉ se folose»ôte pentru a salva fi»ôierul de control binar?", answer: "ALTER DATABASE BACKUP CONTROLFILE TO '/oracle/backup/control.bkp';" },
            { id: 12, question: "Cum se genereazƒÉ o secven»õƒÉ SQL pentru recrearea fi»ôierului de control?", answer: "ALTER DATABASE BACKUP CONTROLFILE TO TRACE; Secven»õa SQL se va genera √Æn fi»ôierul TRACE al sesiunii curente." },
            { id: 13, question: "Ce se √Ænt√¢mplƒÉ la MOUNT √Æn rela»õie cu fi»ôierul de control?", answer: "Se deschid fi»ôierele de control »ôi se citesc pentru a localiza fisierele de date »ôi Redo Log." },
            { id: 14, question: "Ce sunt vederile V$DATABASE »ôi V$CONTROLFILE?", answer: "V$DATABASE con»õine date despre BD luate din FC. V$CONTROLFILE »ôi V$PARAMETER con»õin lista cu numele fisierelor de control." },
            { id: 15, question: "Ce sunt fi»ôierele Redo Log?", answer: "Fi»ôiere prealocate care √ÆnregistreazƒÉ toate modificƒÉrile aduse BD, protej√¢nd-o √Æn caz de e»ôec al instan»õei. Esen»õiale pentru recuperare." },
            { id: 16, question: "Ce se stocheazƒÉ √Æn fi»ôierele Redo Log?", answer: "Toate modificƒÉrile fƒÉcute √Æn Buffer Cache sub formƒÉ de √ÆnregistrƒÉri de Redo. Se folosesc DOAR pentru recuperarea datelor (recovery)." },
            { id: 17, question: "Ce este un grup de Redo Log?", answer: "Fi»ôierele Redo Log folosite sunt √ÆmpƒÉr»õite √Æn grupuri. Un grup poate con»õine mai mul»õi membri (fi»ôiere identice care se scriu simultan - multiplexare)." },
            { id: 18, question: "Care este rolul multiplexƒÉrii √Æn Redo Log?", answer: "ProtejeazƒÉ √Æmpotriva pierderii de date dacƒÉ uno dintre fi»ôierele fizice este pierdut sau corupt. To»õi membrii unui grup se scriu simultan de LGWR." },
            { id: 19, question: "Ce este log sequence number?", answer: "Un numƒÉr asignat de Oracle fiecƒÉrui grup c√¢nd √Æncep sƒÉ scrie √Æn el. To»õi membrii unui grup au acela»ôi log sequence number." },
            { id: 20, question: "C√¢te grupuri de Redo Log sunt necesare minimum?", answer: "Minimum 2 grupuri pentru operarea normalƒÉ a BD Oracle. Maximum 255 grupuri diferite pot exista." },
            { id: 21, question: "Ce sunt parametrii MAXLOGFILES, MAXLOGMEMBERS »ôi LOG_FILES?", answer: "MAXLOGFILES = max. grupuri. MAXLOGMEMBERS = max. membri per grup. LOG_FILES = numƒÉrul de fisiere deschise la runtime (‚â§ MAXLOGFILES √ó MAXLOGMEMBERS)." },
            { id: 22, question: "C√¢nd scrie LGWR √Æn fi»ôierele Redo Log?", answer: "1. La COMMIT. 2. C√¢nd Redo Log Buffer este plin. 3. La timeout LGWR (3 secunde). 4. √énainte ca DBWR sƒÉ scrie blocurile modificate." },
            { id: 23, question: "Ce este log switch?", answer: "Schimbarea de la un fisier (grup) Redo Log la urmƒÉtorul c√¢nd se umple. La fiecare log switch se asociazƒÉ un nou numƒÉr de secven»õƒÉ." },
            { id: 24, question: "Ce se √Ænt√¢mplƒÉ la fiecare log switch?", answer: "Se asociazƒÉ un nou numƒÉr de secven»õƒÉ noului fisier »ôi se ini»õiazƒÉ automat un Checkpoint." },
            { id: 25, question: "Cum se for»õeazƒÉ un log switch?", answer: "ALTER SYSTEM SWITCH LOGFILE; DBA-ul poate for»õa schimbarea chiar dacƒÉ fisierul curent nu este plin." },
            { id: 26, question: "Ce este un Checkpoint?", answer: "Proces care ajutƒÉ la recuperare rapidƒÉ a BD prin scriere pe disc a datelor modificate »ôi declarare a tranzac»õiilor finalizate. Reduce timp de recuperare." },
            { id: 27, question: "Ce se executƒÉ la apari»õia unui Checkpoint?", answer: "1. Toate blocurile modificate (dirty) din memorie sunt scrise pe disc de DBWR. 2. CKPT actualizeazƒÉ antetele fisierelor de control »ôi date." },
            { id: 28, question: "C√¢nd apare automat un Checkpoint?", answer: "1. La fiecare log switch. 2. La oprire √Æn modurile normal, tranzac»õional »ôi imediat. 3. La parametrii LOG_CHECKPOINT_INTERVAL »ôi LOG_CHECKPOINT_TIMEOUT." },
            { id: 29, question: "Cum se for»õeazƒÉ manual un Checkpoint?", answer: "ALTER SYSTEM CHECKPOINT; Aceasta asigurƒÉ consisten»õa fisierelor »ôi se folose»ôte pentru pregatire la backup/oprire." },
            { id: 30, question: "Care sunt stƒÉrile unui fi»ôier Redo Log?", answer: "1. CURRENT - cel √Æn care se scrie. 2. ACTIVE - s-a scris anterior, modificƒÉri nu sunt pe disc. 3. INACTIVE - modificƒÉri sunt pe disc. 4. UNUSED - nou, nu s-a scris." },
            { id: 31, question: "Ce este arhivarea fi»ôierelor Redo Log?", answer: "Salvare de copii ale fisierelor Redo Log active √Ænainte de suprascrise. Esen»õialƒÉ pentru Point-in-Time Recovery »ôi Data Guard." },
            { id: 32, question: "Care este diferen»õa dintre NOARCHIVELOG »ôi ARCHIVELOG?", answer: "NOARCHIVELOG: c√¢nd ultimul fisier se umple, se rescrie (pierdere date). ARCHIVELOG: dupƒÉ log switch, fisierele inactive sunt arhivate de ARCn." },
            { id: 33, question: "Ce permite arhivarea fisierelor Redo Log?", answer: "Refacerea BD de la 0 pornind de la o salvare la un moment dat »ôi fisierele Redo Log care au √Ænregistrat modificƒÉri dupƒÉ salvare (Point-in-Time Recovery)." },
            { id: 34, question: "Ce este procesul ARCn?", answer: "Proces de background care copiazƒÉ automat un fisier Redo Log plin √Æntr-un director de arhivƒÉ √Æn modul ARCHIVELOG." },
            { id: 35, question: "Cum se vizualizeazƒÉ modul curent al BD (ARCHIVELOG)?", answer: "Cu vederea v$database care oferƒÉ informa»õii din fisierul de control, sau cu comanda log_archive_start √Æn SQL*Plus." },
            { id: 36, question: "Ce informa»õii afi»ôeazƒÉ vederea V$LOG?", answer: "Informa»õii despre fisierele Redo Log (luate din fisierele de control): GROUP#, STATUS, ARCHIVED, SEQUENCE# etc." },
            { id: 37, question: "Ce informa»õii afi»ôeazƒÉ vederea V$LOGFILE?", answer: "Informa»õii despre fisierele Redo Log: GROUP#, STATUS, TYPE (ONLINE/STANDBY), MEMBER (nume fisier), zona recuperare." },
            { id: 38, question: "Ce valori poate lua coloana STATUS din V$LOGFILE?", answer: "NULL (fisier utilizat), INVALID (neaccesibil), STALE (incomplet/incorect), DELETED (»ôters)." },
            { id: 39, question: "Cum se adaugƒÉ un nou grup Redo Log?", answer: "ALTER DATABASE ADD LOGFILE GROUP n (membre) SIZE size; Numar grup este op»õional. Evita numerotarea pe sƒÉrite (10,20,30...)." },
            { id: 40, question: "Cum se adaugƒÉ noi membri la un grup Redo Log?", answer: "ALTER DATABASE ADD LOGFILE MEMBER 'fisier' TO GROUP n; DacƒÉ fisierul existƒÉ cu dimensiune corectƒÉ, se folose»ôte clauza REUSE." },
            { id: 41, question: "Cum se redenume»ôte/relocalizeazƒÉ un fi»ôier Redo Log?", answer: "1. SHUTDOWN. 2. mv/cp cu comenzi OS √Æn noua loca»õie. 3. STARTUP MOUNT. 4. ALTER DATABASE RENAME FILE. 5. ALTER DATABASE OPEN." },
            { id: 42, question: "Care sunt condi»õiile pentru a »ôterge un grup Redo Log?", answer: "1. Trebuie sƒÉ rƒÉm√¢nƒÉ min 2 grupuri. 2. Grupul trebuie INACTIVE. 3. DacƒÉ e curent, for»õeazƒÉ log switch. 4. Trebuie arhivat." },
            { id: 43, question: "Cum se »ôterge un grup Redo Log?", answer: "ALTER DATABASE DROP LOGFILE GROUP n; sau se poate specifica prin lista membrilor. Nu »ôterge fisierul fizic, doar actualizƒÉri interne." },
            { id: 44, question: "Cum se »ôterge un membru dintr-un grup Redo Log?", answer: "ALTER DATABASE DROP LOGFILE MEMBER 'fisier'; Nu se poate »ôterge ultimul membru valid dacƒÉ nu rƒÉm√¢n min 2 grupuri valide." },
            { id: 45, question: "Ce este CLEAR LOGFILE?", answer: "ALTER DATABASE CLEAR LOGFILE GROUP n; ReinitializeazƒÉ un grup corupt. DacƒÉ nu e arhivat: CLEAR UNARCHIVED LOGFILE." },
            { id: 46, question: "Ce parametri controleazƒÉ Checkpoint automat?", answer: "LOG_CHECKPOINT_INTERVAL = blocuri OS √Ænainte de checkpoint. LOG_CHECKPOINT_TIMEOUT = secunde de la precedentul checkpoint (default 1800)." },
            { id: 47, question: "Ce face LOG_CHECKPOINT_INTERVAL?", answer: "SpecificƒÉ numƒÉrul de blocuri OS care trebuie scrise de LGWR √Ænainte de ini»õiere Checkpoint. Valoare 0 = ignorat." },
            { id: 48, question: "Ce face LOG_CHECKPOINT_TIMEOUT?", answer: "SpecificƒÉ interval de timp (secunde) de la precedentul checkpoint. GaranteazƒÉ cƒÉ niciun dirty block nu rƒÉm√¢ne √Æn memorie mai mult dec√¢t valoarea setatƒÉ." },
            { id: 49, question: "Care este logica de recuperare cu fi»ôiere Redo Log?", answer: "DacƒÉ BD cade, SMON folose»ôte fisierele Redo Log curente »ôi active pentru a rescrie modificƒÉri care nu au fost scrise pe disc p√¢nƒÉ la incident." },
            { id: 50, question: "Ce vederi sunt disponibile pentru informa»õii despre Redo Log?", answer: "V$THREAD, V$LOG, V$LOGFILE, V$INSTANCE pentru a vizualiza starea fisierelor »ôi grupurilor Redo Log." },
            { id: 51, question: "Cum se vizualizeazƒÉ grupul curent de Redo Log?", answer: "SELECT * FROM V$THREAD; pentru a vedea care este fisierul (grupul) curent √Æn care se scrie." }
        ];

        // State management (in-memory)
        let currentIndex = 0;
        let isFlipped = false;
        let currentDeck = [...flashcardsData];
        let originalDeck = [...flashcardsData];

        // DOM elements
        const flashcard = document.getElementById('flashcard');
        const questionEl = document.getElementById('question');
        const answerEl = document.getElementById('answer');
        const progressEl = document.getElementById('progress');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const resetBtn = document.getElementById('resetBtn');

        // Initialize the app
        function init() {
            renderCard();
            updateProgress();
            updateButtonStates();
        }

        // Render current card
        function renderCard() {
            const card = currentDeck[currentIndex];
            questionEl.textContent = card.question;
            answerEl.textContent = card.answer;
            
            // Reset flip state when changing cards
            if (isFlipped) {
                flipCard();
            }
        }

        // Flip the card
        function flipCard() {
            isFlipped = !isFlipped;
            flashcard.classList.toggle('flipped');
        }

        // Update progress indicator
        function updateProgress() {
            progressEl.textContent = `Card ${currentIndex + 1} / ${currentDeck.length}`;
        }

        // Update button states
        function updateButtonStates() {
            prevBtn.disabled = currentIndex === 0;
            nextBtn.disabled = currentIndex === currentDeck.length - 1;
        }

        // Navigate to previous card
        function previousCard() {
            if (currentIndex > 0) {
                currentIndex--;
                renderCard();
                updateProgress();
                updateButtonStates();
            }
        }

        // Navigate to next card
        function nextCard() {
            if (currentIndex < currentDeck.length - 1) {
                currentIndex++;
                renderCard();
                updateProgress();
                updateButtonStates();
            }
        }

        // Shuffle the deck
        function shuffleDeck() {
            const shuffled = [...currentDeck];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            currentDeck = shuffled;
            currentIndex = 0;
            renderCard();
            updateProgress();
            updateButtonStates();
        }

        // Reset to original order
        function resetDeck() {
            currentDeck = [...originalDeck];
            currentIndex = 0;
            renderCard();
            updateProgress();
            updateButtonStates();
        }

        // Event listeners
        flashcard.addEventListener('click', flipCard);
        
        flashcard.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                flipCard();
            }
        });

        prevBtn.addEventListener('click', previousCard);
        nextBtn.addEventListener('click', nextCard);
        shuffleBtn.addEventListener('click', shuffleDeck);
        resetBtn.addEventListener('click', resetDeck);

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            // Avoid triggering when typing in input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return;
            }

            switch(e.key) {
                case 'ArrowLeft':
                    e.preventDefault();
                    previousCard();
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    nextCard();
                    break;
                case ' ':
                    if (e.target !== flashcard) {
                        e.preventDefault();
                        flipCard();
                    }
                    break;
            }
        });

        // Initialize on load
        init();
    </script>
</body>
</html>